% !TeX program = lualatex
% !TeX encoding = UTF-8
% !TeX root = build/main.tex

\documentclass[12pt,a4paper,draft,openany,oneside,openbib]{report}
 	\input{../init}
\begin{document} 
\maketitle
\chapter{Introduction}



In 2005 M.\! Maietti and G. Sambin \cite{maietti2005toward} argued about the necessity of building a foundation for constructive mathematics to be taken as a common core among relevant existing foundations in axiomatic set theory, such as Aczel-Myhill's CZF and Mizar's TG set theory, or in category theory, such as the internal theory of a topos, or in type theory, such as Martin-Lof’s type theory and Coquand’s Calculus of Inductive Constructions. 
Moreover, they asked the foundation to satisfy the “proofs-as-programs” paradigm, namely the existence of a realizability model where to extract programs from proofs. 
Finally, the authors wanted the theory to be appealing to standard mathematicians and therefore they wanted extensionality in the theory, \eg to reason with quotient types and to avoid the intricacies of dependent types in intensional theories.

In the same paper they noticed that theories satisfying extensional properties, like extensionality of functions, can not satisfy the proofs-as-programs requirement.
Therefore they concluded that in a proofs-as-programs theory one can only represent extensional concepts by modelling them via intensional ones in a suitable way, as already partially shown in some categorical contexts.

Finally, they ended up proposing a constructive foundation for mathematics equipped with two levels: an intensional level that acts as a programming language and is the actual proofs-as-programs theory; and an extensional level that acts as the set theory where to formalize mathematical proofs. Then, the constructivity of the whole foundation relies on the fact that the extensional level must be implemented over the intensional level, but not only this. Indeed, following Sambin’s forget-restore principle, they also required that extensional concepts must be abstractions of intensional ones as result of forgetting irrelevant computational information.
Such information is then restored when extensional concepts are translated back at the intensional level.


In 2009 M. Maietti \cite{maietti2009minimalist} presented the syntax and judgements of the two levels, together with a proof that a suitable completion of the intentional level provides a model of the extensional one. The proof is constructive and based on a sequence of categorical constructions, the most important being the construction of a quotient model within the intensional level, where setoids are used to encode extensional equality in an intensional language, and a notion of canonical isomorphism between intensional dependent setoids.
	

In this work we will present an implementation of the following software components:
\begin{enumerate}
	\item a type checker for the intensional level
	\item a reformulation of the extensional level that allows to store sintactically proof objects that are later used to provide the information to be restored when going from the extensional to the intensional level so to avoid general proof search during the interpretation
	\item a type checker for the obtained extensional level
	\item a translator from well-typed extensional terms to well-typed intensional terms
\end{enumerate}


Combining the translator with a proof extraction component it will be possible to extract programs from proofs written in the extensional level.

We have chosen LambdaProlog \cite{nadatur}(and its recent implementation ELPI [4]) as the programming language to write the two type checkers and the translator. The benefits are that LambdaProlog takes care of the intricacies of dealing with binders and alpha-conversion and moreover a LambdaProlog implementation of a syntax-directed judgement is just made of simple clauses that are almost literal translations of the judgemental rules. This allows humans (and logicians in particular) to easily inspect the code to spot possible errors.

\input{../document}
%\nocite{*}
\input{../biblio}
\end{document}